// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package models

import "encoding/json"
import "fmt"
import "reflect"
import "time"

type AgentLameduckSetEvent struct {
	// Indicates if the lameduck setting was successful
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentLameduckSetEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in AgentLameduckSetEvent: required")
	}
	type Plain AgentLameduckSetEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentLameduckSetEvent(plain)
	return nil
}

type AgentStartedEvent struct {
	// The unique identifier of the nex agent
	Id string `json:"id"`

	// The name of the agent
	Name string `json:"name"`

	// The type of the agent
	Type AgentStartedEventType `json:"type"`
}

type AgentStartedEventType string

const AgentStartedEventTypeEmbedded AgentStartedEventType = "embedded"
const AgentStartedEventTypeLocal AgentStartedEventType = "local"
const AgentStartedEventTypeRemote AgentStartedEventType = "remote"

var enumValues_AgentStartedEventType = []interface{}{
	"embedded",
	"local",
	"remote",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentStartedEventType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AgentStartedEventType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AgentStartedEventType, v)
	}
	*j = AgentStartedEventType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentStartedEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in AgentStartedEvent: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AgentStartedEvent: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AgentStartedEvent: required")
	}
	type Plain AgentStartedEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentStartedEvent(plain)
	return nil
}

type AgentStoppedEvent struct {
	// The unique identifier of the nex agent
	Id string `json:"id"`

	// The name of the agent
	Name string `json:"name"`

	// The reason why the agent stopped
	Reason string `json:"reason"`

	// The timestamp when the agent stopped
	Timestamp time.Time `json:"timestamp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentStoppedEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in AgentStoppedEvent: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AgentStoppedEvent: required")
	}
	if _, ok := raw["reason"]; raw != nil && !ok {
		return fmt.Errorf("field reason in AgentStoppedEvent: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in AgentStoppedEvent: required")
	}
	type Plain AgentStoppedEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentStoppedEvent(plain)
	return nil
}

type NexNodeLameduckSetEvent struct {
	// The unique identifier of the nex node
	Id string `json:"id"`

	// The time when the shutdown will begin
	Time time.Time `json:"time"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NexNodeLameduckSetEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in NexNodeLameduckSetEvent: required")
	}
	if _, ok := raw["time"]; raw != nil && !ok {
		return fmt.Errorf("field time in NexNodeLameduckSetEvent: required")
	}
	type Plain NexNodeLameduckSetEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NexNodeLameduckSetEvent(plain)
	return nil
}

type NexNodeStartedEvent struct {
	// The unique identifier of the nex node
	Id string `json:"id"`

	// The name of the nex node
	Name string `json:"name"`

	// Nexus the nex node belongs to
	Nexus string `json:"nexus"`

	// Placement tags associated with the nex node
	Tags NodeTags `json:"tags"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NexNodeStartedEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in NexNodeStartedEvent: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in NexNodeStartedEvent: required")
	}
	if _, ok := raw["nexus"]; raw != nil && !ok {
		return fmt.Errorf("field nexus in NexNodeStartedEvent: required")
	}
	if _, ok := raw["tags"]; raw != nil && !ok {
		return fmt.Errorf("field tags in NexNodeStartedEvent: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in NexNodeStartedEvent: required")
	}
	type Plain NexNodeStartedEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NexNodeStartedEvent(plain)
	return nil
}

type NexNodeStoppedEvent struct {
	// The unique identifier of the nex node
	Id string `json:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NexNodeStoppedEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in NexNodeStoppedEvent: required")
	}
	type Plain NexNodeStoppedEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NexNodeStoppedEvent(plain)
	return nil
}

type WorkloadStartedEvent struct {
	// The unique identifier of the workload
	Id string `json:"id"`

	// The metadata of the workload
	Metadata WorkloadStartedEventMetadata `json:"metadata,omitempty"`

	// The namespace of the workload
	Namespace string `json:"namespace"`

	// The type of the workload, e.g., 'container', 'javascript', etc
	WorkloadType string `json:"workload_type"`
}

// The metadata of the workload
type WorkloadStartedEventMetadata map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkloadStartedEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in WorkloadStartedEvent: required")
	}
	if _, ok := raw["namespace"]; raw != nil && !ok {
		return fmt.Errorf("field namespace in WorkloadStartedEvent: required")
	}
	if _, ok := raw["workload_type"]; raw != nil && !ok {
		return fmt.Errorf("field workload_type in WorkloadStartedEvent: required")
	}
	type Plain WorkloadStartedEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = WorkloadStartedEvent(plain)
	return nil
}

type WorkloadStoppedEvent struct {
	// The error that caused the workload to stop; nil if the workload stopped
	// successfully
	Error *WorkloadStoppedEventError `json:"error,omitempty"`

	// The unique identifier of the workload
	Id string `json:"id"`

	// The metadata of the workload
	Metadata WorkloadStoppedEventMetadata `json:"metadata,omitempty"`

	// The namespace of the workload
	Namespace string `json:"namespace"`

	// The type of the workload, e.g., 'container', 'javascript', etc
	WorkloadType string `json:"workload_type"`
}

// The error that caused the workload to stop; nil if the workload stopped
// successfully
type WorkloadStoppedEventError struct {
	// The error code
	Code string `json:"code"`

	// The error message
	Message string `json:"message"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkloadStoppedEventError) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["code"]; raw != nil && !ok {
		return fmt.Errorf("field code in WorkloadStoppedEventError: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in WorkloadStoppedEventError: required")
	}
	type Plain WorkloadStoppedEventError
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = WorkloadStoppedEventError(plain)
	return nil
}

// The metadata of the workload
type WorkloadStoppedEventMetadata map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkloadStoppedEvent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in WorkloadStoppedEvent: required")
	}
	if _, ok := raw["namespace"]; raw != nil && !ok {
		return fmt.Errorf("field namespace in WorkloadStoppedEvent: required")
	}
	if _, ok := raw["workload_type"]; raw != nil && !ok {
		return fmt.Errorf("field workload_type in WorkloadStoppedEvent: required")
	}
	type Plain WorkloadStoppedEvent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = WorkloadStoppedEvent(plain)
	return nil
}
