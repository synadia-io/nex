// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package models

import "encoding/json"
import "fmt"

type AgentHeartbeat struct {
	// Send additional data in heartbeat
	Data string `json:"data"`

	// The state of the agent. Must be of able to map to models.AgentState
	State string `json:"state"`

	// The number of agents running with workload count
	WorkloadCount int `json:"workload_count"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentHeartbeat) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in AgentHeartbeat: required")
	}
	if _, ok := raw["state"]; raw != nil && !ok {
		return fmt.Errorf("field state in AgentHeartbeat: required")
	}
	if _, ok := raw["workload_count"]; raw != nil && !ok {
		return fmt.Errorf("field workload_count in AgentHeartbeat: required")
	}
	type Plain AgentHeartbeat
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AgentHeartbeat(plain)
	return nil
}

type AgentListWorkloadsRequest struct {
	// Filter to apply to the list of workloads
	Filter []string `json:"filter"`

	// Namespace to list workloads from
	Namespace string `json:"namespace"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentListWorkloadsRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["filter"]; raw != nil && !ok {
		return fmt.Errorf("field filter in AgentListWorkloadsRequest: required")
	}
	if _, ok := raw["namespace"]; raw != nil && !ok {
		return fmt.Errorf("field namespace in AgentListWorkloadsRequest: required")
	}
	type Plain AgentListWorkloadsRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AgentListWorkloadsRequest(plain)
	return nil
}

type AgentListWorkloadsResponse []WorkloadSummary

type RegisterAgentRequest struct {
	// A user friendly description of the agent
	Description string `json:"description"`

	// The maximum number of workloads this agent can hold. 0 indicates unlimited
	MaxWorkloads float64 `json:"max_workloads"`

	// Name of the agent
	Name string `json:"name"`

	// The public xkey of the agent. Node will encrypt environment with this key
	PublicXkey string `json:"public_xkey"`

	// JSONSchema shape for the start request; enforced by node
	StartRequestSchema string `json:"start_request_schema"`

	// List of capabilities supported by the agent
	SupportedLifecycles []WorkloadLifecycle `json:"supported_lifecycles,omitempty"`

	// Version of the agent
	Version string `json:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegisterAgentRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in RegisterAgentRequest: required")
	}
	if _, ok := raw["max_workloads"]; raw != nil && !ok {
		return fmt.Errorf("field max_workloads in RegisterAgentRequest: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RegisterAgentRequest: required")
	}
	if _, ok := raw["public_xkey"]; raw != nil && !ok {
		return fmt.Errorf("field public_xkey in RegisterAgentRequest: required")
	}
	if _, ok := raw["start_request_schema"]; raw != nil && !ok {
		return fmt.Errorf("field start_request_schema in RegisterAgentRequest: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in RegisterAgentRequest: required")
	}
	type Plain RegisterAgentRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegisterAgentRequest(plain)
	return nil
}

type RegisterAgentResponse struct {
	// ConnectionData corresponds to the JSON schema field "connection_data".
	ConnectionData NatsConnectionData `json:"connection_data"`

	// ExistingState corresponds to the JSON schema field "existing_state".
	ExistingState RegisterAgentResponseExistingState `json:"existing_state"`

	// A message indicating the result of the registration
	Message string `json:"message"`

	// The ID of the node the agent is registered to
	NodeId string `json:"node_id"`

	// Indicates if the agent was successfully registered
	Success bool `json:"success"`
}

type RegisterAgentResponseExistingState map[string]AgentStartWorkloadRequest

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegisterAgentResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["connection_data"]; raw != nil && !ok {
		return fmt.Errorf("field connection_data in RegisterAgentResponse: required")
	}
	if _, ok := raw["existing_state"]; raw != nil && !ok {
		return fmt.Errorf("field existing_state in RegisterAgentResponse: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in RegisterAgentResponse: required")
	}
	if _, ok := raw["node_id"]; raw != nil && !ok {
		return fmt.Errorf("field node_id in RegisterAgentResponse: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in RegisterAgentResponse: required")
	}
	type Plain RegisterAgentResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegisterAgentResponse(plain)
	return nil
}
