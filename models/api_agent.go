// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package models

import "encoding/json"
import "fmt"

type AgentHeartbeat struct {
	// Send additional data in heartbeat
	Data string `json:"data"`

	// The state of the agent. Must be of able to map to models.AgentState
	State string `json:"state"`

	// The number of agents running with workload count
	WorkloadCount int `json:"workload_count"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentHeartbeat) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["data"]; raw != nil && !ok {
		return fmt.Errorf("field data in AgentHeartbeat: required")
	}
	if _, ok := raw["state"]; raw != nil && !ok {
		return fmt.Errorf("field state in AgentHeartbeat: required")
	}
	if _, ok := raw["workload_count"]; raw != nil && !ok {
		return fmt.Errorf("field workload_count in AgentHeartbeat: required")
	}
	type Plain AgentHeartbeat
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentHeartbeat(plain)
	return nil
}

type AgentIngressData struct {
	// IP address of the host machine (nex node)
	HostMachineIpAddr string `json:"host_machine_ip_addr"`

	// NATS Subject Ingress messages will be published to
	IngressReportingSubject string `json:"ingress_reporting_subject"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentIngressData) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["host_machine_ip_addr"]; raw != nil && !ok {
		return fmt.Errorf("field host_machine_ip_addr in AgentIngressData: required")
	}
	if _, ok := raw["ingress_reporting_subject"]; raw != nil && !ok {
		return fmt.Errorf("field ingress_reporting_subject in AgentIngressData: required")
	}
	type Plain AgentIngressData
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentIngressData(plain)
	return nil
}

type AgentIngressMsg struct {
	// Command to execute
	Command AgentIngressCommands `json:"command"`

	// Upstream IP address that ingress should forward to
	Upstream string `json:"upstream"`

	// ID of workload
	WorkloadId string `json:"workload_id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentIngressMsg) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["command"]; raw != nil && !ok {
		return fmt.Errorf("field command in AgentIngressMsg: required")
	}
	if _, ok := raw["upstream"]; raw != nil && !ok {
		return fmt.Errorf("field upstream in AgentIngressMsg: required")
	}
	if _, ok := raw["workload_id"]; raw != nil && !ok {
		return fmt.Errorf("field workload_id in AgentIngressMsg: required")
	}
	type Plain AgentIngressMsg
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentIngressMsg(plain)
	return nil
}

type AgentListWorkloadsRequest struct {
	// Filter to apply to the list of workloads
	Filter []string `json:"filter"`

	// Namespace to list workloads from
	Namespace string `json:"namespace"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentListWorkloadsRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["filter"]; raw != nil && !ok {
		return fmt.Errorf("field filter in AgentListWorkloadsRequest: required")
	}
	if _, ok := raw["namespace"]; raw != nil && !ok {
		return fmt.Errorf("field namespace in AgentListWorkloadsRequest: required")
	}
	type Plain AgentListWorkloadsRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = AgentListWorkloadsRequest(plain)
	return nil
}

type AgentListWorkloadsResponse []WorkloadSummary

type RegisterAgentRequest struct {
	// A user friendly description of the agent
	Description string `json:"description"`

	// The maximum number of workloads this agent can hold. 0 indicates unlimited
	MaxWorkloads float64 `json:"max_workloads"`

	// Name of the agent; used primarily for logging
	Name string `json:"name"`

	// The public xkey of the agent. Node will encrypt environment with this key
	PublicXkey string `json:"public_xkey"`

	// Type of registration; will be used when auctioning for placement (--type)
	RegisterType string `json:"register_type"`

	// JSONSchema shape for the start request; enforced by node
	StartRequestSchema string `json:"start_request_schema"`

	// List of capabilities supported by the agent
	SupportedLifecycles []WorkloadLifecycle `json:"supported_lifecycles,omitempty"`

	// Version of the agent
	Version string `json:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegisterAgentRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in RegisterAgentRequest: required")
	}
	if _, ok := raw["max_workloads"]; raw != nil && !ok {
		return fmt.Errorf("field max_workloads in RegisterAgentRequest: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RegisterAgentRequest: required")
	}
	if _, ok := raw["public_xkey"]; raw != nil && !ok {
		return fmt.Errorf("field public_xkey in RegisterAgentRequest: required")
	}
	if _, ok := raw["register_type"]; raw != nil && !ok {
		return fmt.Errorf("field register_type in RegisterAgentRequest: required")
	}
	if _, ok := raw["start_request_schema"]; raw != nil && !ok {
		return fmt.Errorf("field start_request_schema in RegisterAgentRequest: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in RegisterAgentRequest: required")
	}
	type Plain RegisterAgentRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RegisterAgentRequest(plain)
	return nil
}

type RegisterAgentResponse struct {
	// ConnectionData corresponds to the JSON schema field "connection_data".
	ConnectionData NatsConnectionData `json:"connection_data"`

	// ExistingState corresponds to the JSON schema field "existing_state".
	ExistingState RegisterAgentResponseExistingState `json:"existing_state"`

	// A message indicating the result of the registration
	Message string `json:"message"`

	// The ID of the node the agent is registered to
	NodeId string `json:"node_id"`

	// Indicates if the agent was successfully registered
	Success bool `json:"success"`
}

type RegisterAgentResponseExistingState map[string]AgentStartWorkloadRequest

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegisterAgentResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["connection_data"]; raw != nil && !ok {
		return fmt.Errorf("field connection_data in RegisterAgentResponse: required")
	}
	if _, ok := raw["existing_state"]; raw != nil && !ok {
		return fmt.Errorf("field existing_state in RegisterAgentResponse: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in RegisterAgentResponse: required")
	}
	if _, ok := raw["node_id"]; raw != nil && !ok {
		return fmt.Errorf("field node_id in RegisterAgentResponse: required")
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in RegisterAgentResponse: required")
	}
	type Plain RegisterAgentResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RegisterAgentResponse(plain)
	return nil
}

type RegisterRemoteAgentRequest struct {
	// The registration request will need to be signed by this key
	PublicSigningKey string `json:"public_signing_key"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegisterRemoteAgentRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["public_signing_key"]; raw != nil && !ok {
		return fmt.Errorf("field public_signing_key in RegisterRemoteAgentRequest: required")
	}
	type Plain RegisterRemoteAgentRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RegisterRemoteAgentRequest(plain)
	return nil
}

type RegisterRemoteAgentResponse struct {
	// The assigned agent id
	AssignedAgentId string `json:"assigned_agent_id"`

	// Agent registration credentials
	RegistrationCreds *NatsConnectionData `json:"registration_creds,omitempty"`

	// The node waiting for response
	RespondTo string `json:"respond_to"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegisterRemoteAgentResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["assigned_agent_id"]; raw != nil && !ok {
		return fmt.Errorf("field assigned_agent_id in RegisterRemoteAgentResponse: required")
	}
	if _, ok := raw["respond_to"]; raw != nil && !ok {
		return fmt.Errorf("field respond_to in RegisterRemoteAgentResponse: required")
	}
	type Plain RegisterRemoteAgentResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = RegisterRemoteAgentResponse(plain)
	return nil
}
