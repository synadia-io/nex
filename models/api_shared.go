// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package models

import "encoding/json"
import "fmt"
import "reflect"

type AgentStartWorkloadRequest struct {
	// The start workload request
	Request StartWorkloadRequest `json:"request"`

	// The NATS connection data for the workload
	WorkloadCreds NatsConnectionData `json:"workload_creds"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentStartWorkloadRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["request"]; raw != nil && !ok {
		return fmt.Errorf("field request in AgentStartWorkloadRequest: required")
	}
	if _, ok := raw["workload_creds"]; raw != nil && !ok {
		return fmt.Errorf("field workload_creds in AgentStartWorkloadRequest: required")
	}
	type Plain AgentStartWorkloadRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AgentStartWorkloadRequest(plain)
	return nil
}

type AgentSummaries map[string]AgentSummary

type AgentSummary struct {
	// The name of the workload
	Name string `json:"name"`

	// The start time of the workload
	StartTime string `json:"start_time"`

	// The state of the agent
	State string `json:"state"`

	// The lifecycle types supported by the agent
	SupportedLifecycles string `json:"supported_lifecycles"`

	// The version of the agent
	Version string `json:"version"`

	// The number of workloads
	WorkloadCount int `json:"workload_count"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AgentSummary) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AgentSummary: required")
	}
	if _, ok := raw["start_time"]; raw != nil && !ok {
		return fmt.Errorf("field start_time in AgentSummary: required")
	}
	if _, ok := raw["state"]; raw != nil && !ok {
		return fmt.Errorf("field state in AgentSummary: required")
	}
	if _, ok := raw["supported_lifecycles"]; raw != nil && !ok {
		return fmt.Errorf("field supported_lifecycles in AgentSummary: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in AgentSummary: required")
	}
	if _, ok := raw["workload_count"]; raw != nil && !ok {
		return fmt.Errorf("field workload_count in AgentSummary: required")
	}
	type Plain AgentSummary
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AgentSummary(plain)
	return nil
}

type EncEnv struct {
	// Base64EncryptedEnv corresponds to the JSON schema field "base64_encrypted_env".
	Base64EncryptedEnv string `json:"base64_encrypted_env"`

	// EncryptedBy corresponds to the JSON schema field "encrypted_by".
	EncryptedBy string `json:"encrypted_by"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EncEnv) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["base64_encrypted_env"]; raw != nil && !ok {
		return fmt.Errorf("field base64_encrypted_env in EncEnv: required")
	}
	if _, ok := raw["encrypted_by"]; raw != nil && !ok {
		return fmt.Errorf("field encrypted_by in EncEnv: required")
	}
	type Plain EncEnv
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EncEnv(plain)
	return nil
}

type LameduckRequest struct {
	// Time delay before lameduck mode is set
	Delay string `json:"delay"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LameduckRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["delay"]; raw != nil && !ok {
		return fmt.Errorf("field delay in LameduckRequest: required")
	}
	type Plain LameduckRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LameduckRequest(plain)
	return nil
}

type LameduckResponse struct {
	// Indicates lameduck mode successfully set
	Success bool `json:"success"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LameduckResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["success"]; raw != nil && !ok {
		return fmt.Errorf("field success in LameduckResponse: required")
	}
	type Plain LameduckResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LameduckResponse(plain)
	return nil
}

type NatsConnectionData struct {
	// ConnName corresponds to the JSON schema field "conn_name".
	ConnName string `json:"conn_name"`

	// NatsUrl corresponds to the JSON schema field "nats_url".
	NatsUrl string `json:"nats_url"`

	// JWT for nats user, used with Seed
	NatsUserJwt string `json:"nats_user_jwt"`

	// Name of the nats user, used with password
	NatsUserName string `json:"nats_user_name"`

	// NatsUserNkey corresponds to the JSON schema field "nats_user_nkey".
	NatsUserNkey string `json:"nats_user_nkey"`

	// Password for the nats user, used with user name
	NatsUserPassword string `json:"nats_user_password"`

	// Seed for nats user, used with JWT
	NatsUserSeed string `json:"nats_user_seed"`

	// TlsCa corresponds to the JSON schema field "tls_ca".
	TlsCa string `json:"tls_ca"`

	// TlsCert corresponds to the JSON schema field "tls_cert".
	TlsCert string `json:"tls_cert"`

	// TlsFirst corresponds to the JSON schema field "tls_first".
	TlsFirst bool `json:"tls_first"`

	// TlsKey corresponds to the JSON schema field "tls_key".
	TlsKey string `json:"tls_key"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NatsConnectionData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["conn_name"]; raw != nil && !ok {
		return fmt.Errorf("field conn_name in NatsConnectionData: required")
	}
	if _, ok := raw["nats_url"]; raw != nil && !ok {
		return fmt.Errorf("field nats_url in NatsConnectionData: required")
	}
	if _, ok := raw["nats_user_jwt"]; raw != nil && !ok {
		return fmt.Errorf("field nats_user_jwt in NatsConnectionData: required")
	}
	if _, ok := raw["nats_user_name"]; raw != nil && !ok {
		return fmt.Errorf("field nats_user_name in NatsConnectionData: required")
	}
	if _, ok := raw["nats_user_nkey"]; raw != nil && !ok {
		return fmt.Errorf("field nats_user_nkey in NatsConnectionData: required")
	}
	if _, ok := raw["nats_user_password"]; raw != nil && !ok {
		return fmt.Errorf("field nats_user_password in NatsConnectionData: required")
	}
	if _, ok := raw["nats_user_seed"]; raw != nil && !ok {
		return fmt.Errorf("field nats_user_seed in NatsConnectionData: required")
	}
	if _, ok := raw["tls_ca"]; raw != nil && !ok {
		return fmt.Errorf("field tls_ca in NatsConnectionData: required")
	}
	if _, ok := raw["tls_cert"]; raw != nil && !ok {
		return fmt.Errorf("field tls_cert in NatsConnectionData: required")
	}
	if _, ok := raw["tls_first"]; raw != nil && !ok {
		return fmt.Errorf("field tls_first in NatsConnectionData: required")
	}
	if _, ok := raw["tls_key"]; raw != nil && !ok {
		return fmt.Errorf("field tls_key in NatsConnectionData: required")
	}
	type Plain NatsConnectionData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NatsConnectionData(plain)
	return nil
}

type NodeState string

const NodeStateError NodeState = "error"
const NodeStateLameduck NodeState = "lameduck"
const NodeStateRunning NodeState = "running"
const NodeStateStarting NodeState = "starting"
const NodeStateStopping NodeState = "stopping"

var enumValues_NodeState = []interface{}{
	"starting",
	"running",
	"lameduck",
	"stopping",
	"error",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NodeState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NodeState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NodeState, v)
	}
	*j = NodeState(v)
	return nil
}

type NodeTags map[string]string

type StartWorkloadRequest struct {
	// A description of the workload
	Description string `json:"description"`

	// The name of the workload
	Name string `json:"name"`

	// The namespace of the workload
	Namespace string `json:"namespace"`

	// The agent specific run request for the workload
	RunRequest string `json:"run_request"`

	// The lifecycle of the workload
	WorkloadLifecycle WorkloadLifecycle `json:"workload_lifecycle"`

	// The type of the workload
	WorkloadType string `json:"workload_type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartWorkloadRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["description"]; raw != nil && !ok {
		return fmt.Errorf("field description in StartWorkloadRequest: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in StartWorkloadRequest: required")
	}
	if _, ok := raw["namespace"]; raw != nil && !ok {
		return fmt.Errorf("field namespace in StartWorkloadRequest: required")
	}
	if _, ok := raw["run_request"]; raw != nil && !ok {
		return fmt.Errorf("field run_request in StartWorkloadRequest: required")
	}
	if _, ok := raw["workload_lifecycle"]; raw != nil && !ok {
		return fmt.Errorf("field workload_lifecycle in StartWorkloadRequest: required")
	}
	if _, ok := raw["workload_type"]; raw != nil && !ok {
		return fmt.Errorf("field workload_type in StartWorkloadRequest: required")
	}
	type Plain StartWorkloadRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartWorkloadRequest(plain)
	return nil
}

type StartWorkloadResponse struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartWorkloadResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in StartWorkloadResponse: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in StartWorkloadResponse: required")
	}
	type Plain StartWorkloadResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StartWorkloadResponse(plain)
	return nil
}

type StopWorkloadRequest struct {
	// Namespace of the workload to stop
	Namespace string `json:"namespace"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StopWorkloadRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["namespace"]; raw != nil && !ok {
		return fmt.Errorf("field namespace in StopWorkloadRequest: required")
	}
	type Plain StopWorkloadRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StopWorkloadRequest(plain)
	return nil
}

type StopWorkloadResponse struct {
	// Id corresponds to the JSON schema field "id".
	Id string `json:"id"`

	// Message corresponds to the JSON schema field "message".
	Message string `json:"message"`

	// Stopped corresponds to the JSON schema field "stopped".
	Stopped bool `json:"stopped"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StopWorkloadResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in StopWorkloadResponse: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in StopWorkloadResponse: required")
	}
	if _, ok := raw["stopped"]; raw != nil && !ok {
		return fmt.Errorf("field stopped in StopWorkloadResponse: required")
	}
	type Plain StopWorkloadResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StopWorkloadResponse(plain)
	return nil
}

type WorkloadLifecycle string

const WorkloadLifecycleFunction WorkloadLifecycle = "function"
const WorkloadLifecycleJob WorkloadLifecycle = "job"
const WorkloadLifecycleService WorkloadLifecycle = "service"

var enumValues_WorkloadLifecycle = []interface{}{
	"service",
	"job",
	"function",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkloadLifecycle) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WorkloadLifecycle {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WorkloadLifecycle, v)
	}
	*j = WorkloadLifecycle(v)
	return nil
}

type WorkloadState string

const WorkloadStateError WorkloadState = "error"
const WorkloadStateRunning WorkloadState = "running"
const WorkloadStateStarting WorkloadState = "starting"
const WorkloadStateStopping WorkloadState = "stopping"
const WorkloadStateWarm WorkloadState = "warm"

var enumValues_WorkloadState = []interface{}{
	"starting",
	"running",
	"warm",
	"stopping",
	"error",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkloadState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WorkloadState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WorkloadState, v)
	}
	*j = WorkloadState(v)
	return nil
}

type WorkloadSummary struct {
	// The unique identifier of the workload
	Id string `json:"id"`

	// Arbitrary data for agent use
	Metadata WorkloadSummaryMetadata `json:"metadata,omitempty"`

	// The name of the workload
	Name string `json:"name"`

	// The runtime of the workload
	Runtime string `json:"runtime"`

	// The start time of the workload
	StartTime string `json:"start_time"`

	// The lifecycle of the workload: service,job,function
	WorkloadLifecycle string `json:"workload_lifecycle"`

	// The state of the workload
	WorkloadState WorkloadState `json:"workload_state"`

	// The type of the workload
	WorkloadType string `json:"workload_type"`
}

// Arbitrary data for agent use
type WorkloadSummaryMetadata map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkloadSummary) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in WorkloadSummary: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in WorkloadSummary: required")
	}
	if _, ok := raw["runtime"]; raw != nil && !ok {
		return fmt.Errorf("field runtime in WorkloadSummary: required")
	}
	if _, ok := raw["start_time"]; raw != nil && !ok {
		return fmt.Errorf("field start_time in WorkloadSummary: required")
	}
	if _, ok := raw["workload_lifecycle"]; raw != nil && !ok {
		return fmt.Errorf("field workload_lifecycle in WorkloadSummary: required")
	}
	if _, ok := raw["workload_state"]; raw != nil && !ok {
		return fmt.Errorf("field workload_state in WorkloadSummary: required")
	}
	if _, ok := raw["workload_type"]; raw != nil && !ok {
		return fmt.Errorf("field workload_type in WorkloadSummary: required")
	}
	type Plain WorkloadSummary
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WorkloadSummary(plain)
	return nil
}
